// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package models

import (
	"context"
	"database/sql"
	"time"
)

const getETL = `-- name: GetETL :one
SELECT sql, last_run
FROM itslog_etl
WHERE
  key_id = ?
  AND
  name = ?
LIMIT 1
`

type GetETLParams struct {
	KeyID string
	Name  string
}

type GetETLRow struct {
	Sql     string
	LastRun sql.NullTime
}

func (q *Queries) GetETL(ctx context.Context, arg GetETLParams) (GetETLRow, error) {
	row := q.db.QueryRowContext(ctx, getETL, arg.KeyID, arg.Name)
	var i GetETLRow
	err := row.Scan(&i.Sql, &i.LastRun)
	return i, err
}

const insertETL = `-- name: InsertETL :exec
INSERT OR REPLACE INTO itslog_etl (
  key_id, name, sql
) VALUES (
  ?, ?, ?
)
`

type InsertETLParams struct {
	KeyID string
	Name  string
	Sql   string
}

// ------------------------------------------------------
// ETL
// ------------------------------------------------------
func (q *Queries) InsertETL(ctx context.Context, arg InsertETLParams) error {
	_, err := q.db.ExecContext(ctx, insertETL, arg.KeyID, arg.Name, arg.Sql)
	return err
}

const logClusteredEvent = `-- name: LogClusteredEvent :one
INSERT INTO itslog_events (
  key_id, cluster_hash, source_hash, event_hash
) VALUES (
  ?, ?, ?, ?
)
RETURNING id
`

type LogClusteredEventParams struct {
	KeyID       string
	ClusterHash sql.NullInt64
	SourceHash  int64
	EventHash   int64
}

func (q *Queries) LogClusteredEvent(ctx context.Context, arg LogClusteredEventParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, logClusteredEvent,
		arg.KeyID,
		arg.ClusterHash,
		arg.SourceHash,
		arg.EventHash,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const logClusteredEventWithValue = `-- name: LogClusteredEventWithValue :one
INSERT INTO itslog_events (
  key_id, timestamp, cluster_hash, source_hash, event_hash, value_hash
) VALUES (
  ?, ?, ?, ?, ?, ?
)
RETURNING id
`

type LogClusteredEventWithValueParams struct {
	KeyID       string
	Timestamp   time.Time
	ClusterHash sql.NullInt64
	SourceHash  int64
	EventHash   int64
	ValueHash   sql.NullInt64
}

func (q *Queries) LogClusteredEventWithValue(ctx context.Context, arg LogClusteredEventWithValueParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, logClusteredEventWithValue,
		arg.KeyID,
		arg.Timestamp,
		arg.ClusterHash,
		arg.SourceHash,
		arg.EventHash,
		arg.ValueHash,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const logEvent = `-- name: LogEvent :one

INSERT INTO itslog_events (
  key_id, source_hash, event_hash
) VALUES (
  ?, ?, ?
)
RETURNING id
`

type LogEventParams struct {
	KeyID      string
	SourceHash int64
	EventHash  int64
}

// https://docs.sqlc.dev/en/latest/tutorials/getting-started-sqlite.html
// ------------------------------------------------------
// LOGGING
// ------------------------------------------------------
func (q *Queries) LogEvent(ctx context.Context, arg LogEventParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, logEvent, arg.KeyID, arg.SourceHash, arg.EventHash)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const logEventWithValue = `-- name: LogEventWithValue :one
INSERT INTO itslog_events (
  key_id, source_hash, event_hash, value_hash
) VALUES (
  ?, ?, ?, ?
)
RETURNING id
`

type LogEventWithValueParams struct {
	KeyID      string
	SourceHash int64
	EventHash  int64
	ValueHash  sql.NullInt64
}

func (q *Queries) LogEventWithValue(ctx context.Context, arg LogEventWithValueParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, logEventWithValue,
		arg.KeyID,
		arg.SourceHash,
		arg.EventHash,
		arg.ValueHash,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const logTimestampedEvent = `-- name: LogTimestampedEvent :one
INSERT INTO itslog_events (
  key_id, timestamp, source_hash, event_hash
) VALUES (
  ?, ?, ?, ?
)
RETURNING id
`

type LogTimestampedEventParams struct {
	KeyID      string
	Timestamp  time.Time
	SourceHash int64
	EventHash  int64
}

// This is largely for generating fake entries.
// However, there may be times where we want to be
// more explicit about the timestamp of an entry.
func (q *Queries) LogTimestampedEvent(ctx context.Context, arg LogTimestampedEventParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, logTimestampedEvent,
		arg.KeyID,
		arg.Timestamp,
		arg.SourceHash,
		arg.EventHash,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const testDictionaryPairExists = `-- name: TestDictionaryPairExists :one
SELECT EXISTS(
  SELECT 1 
  FROM itslog_dictionary
  WHERE 
    source_hash = ?
    AND
    event_hash = ?
  )
`

type TestDictionaryPairExistsParams struct {
	SourceHash int64
	EventHash  int64
}

func (q *Queries) TestDictionaryPairExists(ctx context.Context, arg TestDictionaryPairExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, testDictionaryPairExists, arg.SourceHash, arg.EventHash)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const testEventPairExists = `-- name: TestEventPairExists :one
;


SELECT EXISTS(
  SELECT 1 
  FROM itslog_events 
  WHERE 
    source_hash = ?
    AND
    event_hash = ?
  )
`

type TestEventPairExistsParams struct {
	SourceHash int64
	EventHash  int64
}

// ------------------------------------------------------
// TEST HELPERS
// ------------------------------------------------------
// Used for unit/end-to-end testing.
func (q *Queries) TestEventPairExists(ctx context.Context, arg TestEventPairExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, testEventPairExists, arg.SourceHash, arg.EventHash)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const updateDictionary = `-- name: UpdateDictionary :exec
INSERT OR IGNORE INTO itslog_dictionary (
  key_id, source_name, event_name, source_hash, event_hash
) VALUES (
  ?, ?, ?, ?, ?
)
`

type UpdateDictionaryParams struct {
	KeyID      string
	SourceName string
	EventName  string
	SourceHash int64
	EventHash  int64
}

func (q *Queries) UpdateDictionary(ctx context.Context, arg UpdateDictionaryParams) error {
	_, err := q.db.ExecContext(ctx, updateDictionary,
		arg.KeyID,
		arg.SourceName,
		arg.EventName,
		arg.SourceHash,
		arg.EventHash,
	)
	return err
}

const updateLastRun = `-- name: UpdateLastRun :exec
;

UPDATE itslog_etl
  SET 
    last_run = CURRENT_TIMESTAMP 
WHERE 
  key_id = ?
  AND
  name = ?
`

type UpdateLastRunParams struct {
	KeyID string
	Name  string
}

func (q *Queries) UpdateLastRun(ctx context.Context, arg UpdateLastRunParams) error {
	_, err := q.db.ExecContext(ctx, updateLastRun, arg.KeyID, arg.Name)
	return err
}

const updateLookup = `-- name: UpdateLookup :exec
INSERT OR IGNORE INTO itslog_lookup (
  key_id, hash, name
) VALUES (
  ?, ?, ?
)
`

type UpdateLookupParams struct {
	KeyID string
	Hash  int64
	Name  string
}

func (q *Queries) UpdateLookup(ctx context.Context, arg UpdateLookupParams) error {
	_, err := q.db.ExecContext(ctx, updateLookup, arg.KeyID, arg.Hash, arg.Name)
	return err
}

const updateMeta = `-- name: UpdateMeta :exec
INSERT OR REPLACE INTO itslog_metadata (
  key_id, key, value
) VALUES (
  ?, ?, ?
)
`

type UpdateMetaParams struct {
	KeyID string
	Key   int64
	Value string
}

// ------------------------------------------------------
// METADATA
// ------------------------------------------------------
func (q *Queries) UpdateMeta(ctx context.Context, arg UpdateMetaParams) error {
	_, err := q.db.ExecContext(ctx, updateMeta, arg.KeyID, arg.Key, arg.Value)
	return err
}
