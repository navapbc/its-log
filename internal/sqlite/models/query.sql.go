// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package models

import (
	"context"
	"database/sql"
	"time"
)

const deleteSummaryData = `-- name: DeleteSummaryData :exec
;


DELETE FROM itslog_summary
`

func (q *Queries) DeleteSummaryData(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteSummaryData)
	return err
}

const eventCountsByTheHour = `-- name: EventCountsByTheHour :many
SELECT 
  strftime('%H', timestamp) AS hour,
  source,
  event,
  COUNT(*) AS event_count
FROM itslog_events
GROUP BY hour, source, event
ORDER BY hour, source, event
`

type EventCountsByTheHourRow struct {
	Hour       interface{}
	Source     int64
	Event      int64
	EventCount int64
}

// ----------------------
// By the hour
// ----------------------
func (q *Queries) EventCountsByTheHour(ctx context.Context) ([]EventCountsByTheHourRow, error) {
	rows, err := q.db.QueryContext(ctx, eventCountsByTheHour)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventCountsByTheHourRow
	for rows.Next() {
		var i EventCountsByTheHourRow
		if err := rows.Scan(
			&i.Hour,
			&i.Source,
			&i.Event,
			&i.EventCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const eventCountsForTheDay = `-- name: EventCountsForTheDay :many
SELECT 
  source,
  event,
  COUNT(*) AS event_count
FROM itslog_events
GROUP BY source, event
ORDER BY source, event
`

type EventCountsForTheDayRow struct {
	Source     int64
	Event      int64
	EventCount int64
}

// ----------------------
// By the day
// ----------------------
func (q *Queries) EventCountsForTheDay(ctx context.Context) ([]EventCountsForTheDayRow, error) {
	rows, err := q.db.QueryContext(ctx, eventCountsForTheDay)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventCountsForTheDayRow
	for rows.Next() {
		var i EventCountsForTheDayRow
		if err := rows.Scan(&i.Source, &i.Event, &i.EventCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventName = `-- name: GetEventName :one
SELECT
  event_name
  FROM itslog_dictionary
  WHERE
    source_hash = ?
    AND
    event_hash = ?
  LIMIT 1
`

type GetEventNameParams struct {
	SourceHash int64
	EventHash  int64
}

func (q *Queries) GetEventName(ctx context.Context, arg GetEventNameParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getEventName, arg.SourceHash, arg.EventHash)
	var event_name string
	err := row.Scan(&event_name)
	return event_name, err
}

const getEventNamesForSource = `-- name: GetEventNamesForSource :many
;

SELECT
  event_name
  FROM
  itslog_dictionary
  WHERE 
  source_name = ?
`

func (q *Queries) GetEventNamesForSource(ctx context.Context, sourceName string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getEventNamesForSource, sourceName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var event_name string
		if err := rows.Scan(&event_name); err != nil {
			return nil, err
		}
		items = append(items, event_name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetadata = `-- name: GetMetadata :one
SELECT key, value FROM itslog_metadata
  WHERE key = ? LIMIT 1
`

type GetMetadataRow struct {
	Key   string
	Value string
}

func (q *Queries) GetMetadata(ctx context.Context, key string) (GetMetadataRow, error) {
	row := q.db.QueryRowContext(ctx, getMetadata, key)
	var i GetMetadataRow
	err := row.Scan(&i.Key, &i.Value)
	return i, err
}

const getSourceName = `-- name: GetSourceName :one
SELECT
  source_name
  FROM itslog_dictionary
  WHERE
    source_hash = ?
  LIMIT 1
`

// ----------------------
// Summary helpers
// ----------------------
func (q *Queries) GetSourceName(ctx context.Context, sourceHash int64) (string, error) {
	row := q.db.QueryRowContext(ctx, getSourceName, sourceHash)
	var source_name string
	err := row.Scan(&source_name)
	return source_name, err
}

const getSourceNames = `-- name: GetSourceNames :many
SELECT
  source_name
  FROM 
  itslog_dictionary
`

func (q *Queries) GetSourceNames(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getSourceNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var source_name string
		if err := rows.Scan(&source_name); err != nil {
			return nil, err
		}
		items = append(items, source_name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertMetadata = `-- name: InsertMetadata :exec

INSERT OR REPLACE INTO itslog_metadata (key, value) 
  VALUES (?, ?)
`

type InsertMetadataParams struct {
	Key   string
	Value string
}

// ------------------------------------------------------
// METADATA
// ------------------------------------------------------
func (q *Queries) InsertMetadata(ctx context.Context, arg InsertMetadataParams) error {
	_, err := q.db.ExecContext(ctx, insertMetadata, arg.Key, arg.Value)
	return err
}

const insertSummary = `-- name: InsertSummary :exec
INSERT OR REPLACE INTO itslog_summary (
  operation, source, event, value 
  ) VALUES (
  ?, ?, ?, ?
  )
`

type InsertSummaryParams struct {
	Operation string
	Source    string
	Event     sql.NullString
	Value     float64
}

// ------------------------------------------------------
// SUMMARIZING DATA
// ------------------------------------------------------
func (q *Queries) InsertSummary(ctx context.Context, arg InsertSummaryParams) error {
	_, err := q.db.ExecContext(ctx, insertSummary,
		arg.Operation,
		arg.Source,
		arg.Event,
		arg.Value,
	)
	return err
}

const logEvent = `-- name: LogEvent :one

INSERT INTO itslog_events (
  source, event
) VALUES (
  ?, ?
)
RETURNING id
`

type LogEventParams struct {
	Source int64
	Event  int64
}

// https://docs.sqlc.dev/en/latest/tutorials/getting-started-sqlite.html
func (q *Queries) LogEvent(ctx context.Context, arg LogEventParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, logEvent, arg.Source, arg.Event)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const logTimestampedEvent = `-- name: LogTimestampedEvent :one
INSERT INTO itslog_events (
  timestamp, source, event
) VALUES (
  ?, ?, ?
)
RETURNING id
`

type LogTimestampedEventParams struct {
	Timestamp time.Time
	Source    int64
	Event     int64
}

// This is largely for generating fake entries.
// However, there may be times where we want to be
// more explicit about the timestamp of an entry.
func (q *Queries) LogTimestampedEvent(ctx context.Context, arg LogTimestampedEventParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, logTimestampedEvent, arg.Timestamp, arg.Source, arg.Event)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const sourceCountsByTheHour = `-- name: SourceCountsByTheHour :many
SELECT 
  strftime('%H', timestamp) AS hour,
  source,
  event,
  COUNT(*) AS source_count
FROM itslog_events
GROUP BY hour, source
ORDER BY hour, source
`

type SourceCountsByTheHourRow struct {
	Hour        interface{}
	Source      int64
	Event       int64
	SourceCount int64
}

func (q *Queries) SourceCountsByTheHour(ctx context.Context) ([]SourceCountsByTheHourRow, error) {
	rows, err := q.db.QueryContext(ctx, sourceCountsByTheHour)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SourceCountsByTheHourRow
	for rows.Next() {
		var i SourceCountsByTheHourRow
		if err := rows.Scan(
			&i.Hour,
			&i.Source,
			&i.Event,
			&i.SourceCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sourceCountsForTheDay = `-- name: SourceCountsForTheDay :many
SELECT 
  source,
  COUNT(*) AS source_count
FROM itslog_events
GROUP BY source
ORDER BY source
`

type SourceCountsForTheDayRow struct {
	Source      int64
	SourceCount int64
}

func (q *Queries) SourceCountsForTheDay(ctx context.Context) ([]SourceCountsForTheDayRow, error) {
	rows, err := q.db.QueryContext(ctx, sourceCountsForTheDay)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SourceCountsForTheDayRow
	for rows.Next() {
		var i SourceCountsForTheDayRow
		if err := rows.Scan(&i.Source, &i.SourceCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const testDictionaryPairExists = `-- name: TestDictionaryPairExists :one
SELECT EXISTS(
  SELECT 1 
  FROM itslog_dictionary
  WHERE 
    source_hash = ?
    AND
    event_hash = ?
  )
`

type TestDictionaryPairExistsParams struct {
	SourceHash int64
	EventHash  int64
}

func (q *Queries) TestDictionaryPairExists(ctx context.Context, arg TestDictionaryPairExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, testDictionaryPairExists, arg.SourceHash, arg.EventHash)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const testEventPairExists = `-- name: TestEventPairExists :one

SELECT EXISTS(
  SELECT 1 
  FROM itslog_events 
  WHERE 
    source = ?
    AND
    event = ?
  )
`

type TestEventPairExistsParams struct {
	Source int64
	Event  int64
}

// NAH name: ResetSummaryDataSequence :exec
// DELETE FROM SQLITE_SEQUENCE WHERE name='table_name';
// ------------------------------------------------------
// TEST HELPERS
// ------------------------------------------------------
// Used for unit/end-to-end testing.
func (q *Queries) TestEventPairExists(ctx context.Context, arg TestEventPairExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, testEventPairExists, arg.Source, arg.Event)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const updateDictionary = `-- name: UpdateDictionary :exec
INSERT OR IGNORE INTO itslog_dictionary (
  source_name, event_name, source_hash, event_hash
) VALUES (
  ?, ?, ?, ?
)
`

type UpdateDictionaryParams struct {
	SourceName string
	EventName  string
	SourceHash int64
	EventHash  int64
}

func (q *Queries) UpdateDictionary(ctx context.Context, arg UpdateDictionaryParams) error {
	_, err := q.db.ExecContext(ctx, updateDictionary,
		arg.SourceName,
		arg.EventName,
		arg.SourceHash,
		arg.EventHash,
	)
	return err
}
